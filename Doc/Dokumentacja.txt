załozenia / decyzje architektoniczne

# input
wszystkie kliknięcia przechwytuje input manager
analizuje najpierw canvas ui (w oparciu o event system), potem layer ui, a potem layer water (hexy)
każdy element ui ma mieć layer (ui) i ID (pole skryptu) precyzyjnie określające co to za element, oraz skrypt IClickable z dostępem do orkiestratora via referencje sceny

# logika gry
orkiestrator przyjmuje informcje o inpucie
dodaje kontekst dobierając konieczne informacje
wywołuje swój silnik decyzyjny "rule engine" - on ma być static i testowalny w oderwaniu od reszty
	silnik ignoruje pola o wartości NA
odbiera listę wysokopoziomowych akcji do wykonania od silnika decyzyjnego 
pieczołowicie je wykonuje dobierając konieczne informacje

# referencje
scena ma managera refrencji sceny
jeżeli jakiś komponent jest potrzebny innemu komponentowi, manager referencji dostaje do niego referencje
jeżeli jakiś komponent potrzebuje choc jednego innego komponentu, dostaje referencję do managera referencji
i z niego sobie bierze manager_ref_sceny.potrzebny_komponent.potrzebna_metoda()
ponieważ prefaby nie zachowują referencji do elementów hierarchii (gubi im się zawartość zmiennej public na managera referencji), manager referencji jest singletonem

# overlay
ma być niszczony i odtwarzany od nowa; pod to są zrobione szczegóły, pooling będzie zbędny

# obszary interakcji
to są zbiory hexów w których może nastąpić jakaś interakja dla samolotu na 0, 0 z kierunkiem NW
można to przekształcić na inny kierunek https://www.redblobgames.com/grids/hexagons/#rotation
można to przesunąć do zadanej pozycji (pozycji samolotu) 
powstaje zbiór punktów którym możemy filtrować np. listę pozycji przeciwników